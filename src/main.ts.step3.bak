// Backup before implementing Step 3 (crafting)
// This file is a copy of src/main.ts as of Step 2 implementation.

// @deno-types="npm:@types/leaflet"
import leaflet from "leaflet";

import "leaflet/dist/leaflet.css";
import "./_leafletWorkaround.ts";
import luck from "./_luck.ts";
import "./style.css";

// Basic UI: control panel, map, status
const controlPanelDiv = document.createElement("div");
controlPanelDiv.id = "controlPanel";
document.body.append(controlPanelDiv);

const mapDiv = document.createElement("div");
mapDiv.id = "map";
document.body.append(mapDiv);

const statusPanelDiv = document.createElement("div");
statusPanelDiv.id = "statusPanel";
document.body.append(statusPanelDiv);

// Classroom origin: tile indices are computed relative to this point
const CLASSROOM_LATLNG = leaflet.latLng(
  36.997936938057016,
  -122.05703507501151,
);

// Tunables for the map grid
const TILE_DEGREES = 1e-4; // size of a cell in degrees
const INTERACTION_RADIUS = 2; // in cell units (Chebyshev distance)
const SPAWN_PROBABILITY = 0.12; // deterministic spawn chance via luck()

// Create the map: allow panning; fix zoom to keep cell scale stable
const MAP_ZOOM = 19;
const map = leaflet.map(mapDiv, {
  center: CLASSROOM_LATLNG,
  zoom: MAP_ZOOM,
  minZoom: MAP_ZOOM,
  maxZoom: MAP_ZOOM,
  zoomControl: false,
  scrollWheelZoom: true,
});

leaflet
  .tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution:
      '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
  })
  .addTo(map);

// Player marker (represents where interactions are allowed)
const playerMarker = leaflet.marker(CLASSROOM_LATLNG, { interactive: false });
playerMarker.bindTooltip("You (interaction center)");
playerMarker.addTo(map);

statusPanelDiv.innerText = "Map initialized — showing deterministic cells.";

// Inventory state (Step 2)
let heldToken = null;

// Track cells from which tokens have been picked up this session
const pickedUpCells = new Set(); // keys are "i,j"

function statusText() {
  return heldToken ? `Holding token: ${heldToken.value}` : `Holding: (empty)`;
}

function updateStatusPanel() {
  statusPanelDiv.innerText = `Map initialized — showing deterministic cells.\n${statusText()}`;
}

updateStatusPanel();

// LayerGroup to hold currently visible cell rectangles
const cellsLayer = leaflet.layerGroup().addTo(map);

function latLngToCell(origin: leaflet.LatLng, latlng: leaflet.LatLng) {
  const i = Math.floor((latlng.lat - origin.lat) / TILE_DEGREES);
  const j = Math.floor((latlng.lng - origin.lng) / TILE_DEGREES);
  return { i, j };
}

function cellBounds(origin: leaflet.LatLng, i: number, j: number) {
  return leaflet.latLngBounds([
    [origin.lat + i * TILE_DEGREES, origin.lng + j * TILE_DEGREES],
    [origin.lat + (i + 1) * TILE_DEGREES, origin.lng + (j + 1) * TILE_DEGREES],
  ]);
}

function drawCellsInView() {
  cellsLayer.clearLayers();
  const bounds = map.getBounds();
  const origin = CLASSROOM_LATLNG;

  const iMin = Math.floor((bounds.getSouth() - origin.lat) / TILE_DEGREES);
  const iMax = Math.floor((bounds.getNorth() - origin.lat) / TILE_DEGREES);
  const jMin = Math.floor((bounds.getWest() - origin.lng) / TILE_DEGREES);
  const jMax = Math.floor((bounds.getEast() - origin.lng) / TILE_DEGREES);

  const playerCell = latLngToCell(origin, playerMarker.getLatLng());

  for (let i = iMin; i <= iMax; i++) {
    for (let j = jMin; j <= jMax; j++) {
      const boundsRect = cellBounds(origin, i, j);

      // deterministic: whether this cell contains a token
      const hasToken = luck([i, j, "token"].toString()) < SPAWN_PROBABILITY;
      const tokenValue = Math.floor(luck([i, j, "value"].toString()) * 100);

      // interactive if within INTERACTION_RADIUS of player cell
      const cheb = Math.max(
        Math.abs(i - playerCell.i),
        Math.abs(j - playerCell.j),
      );
      const interactive = cheb <= INTERACTION_RADIUS;

      const rect = leaflet.rectangle(boundsRect, {
        color: interactive ? "#1f78b4" : "#888",
        weight: interactive ? 1.5 : 0.8,
        fillColor: hasToken ? "orange" : "transparent",
        fillOpacity: hasToken ? 0.6 : 0.0,
        interactive: true,
      });

      rect.addTo(cellsLayer);

      // Popup content: deterministic info about this cell
      const popup = `<div>Cell <strong>${i},${j}</strong><br/>` +
        (hasToken ? `Token: <strong>${tokenValue}</strong>` : `Empty`) +
        (interactive
          ? `<br/><em>Within interaction range</em>`
          : `<br/><em>Too far</em>`) +
        `</div>`;

      rect.bindPopup(popup);

      // Click behavior: only allow actions when interactive
      rect.on("click", () => {
        const key = `${i},${j}`;

        // recompute whether the cell currently has a token (account for pickups)
        const initialHasToken = luck([i, j, "token"].toString()) < SPAWN_PROBABILITY;
        const currentlyHasToken = initialHasToken && !pickedUpCells.has(key);

        if (!interactive) {
          rect.bindPopup(`<div>Cell <strong>${i},${j}</strong><br/>${currentlyHasToken ? `Token: <strong>${tokenValue}</strong>` : `Empty`}<br/><em>Too far</em></div>`);
          rect.openPopup();
          return;
        }

        // If player is not holding a token and this cell has one, pick it up
        if (currentlyHasToken && !heldToken) {
          // pick up
          pickedUpCells.add(key);
          heldToken = { value: tokenValue };
          updateStatusPanel();

          // update rectangle style to remove the token fill
          rect.setStyle({ fillOpacity: 0, fillColor: "transparent" });

          rect.bindPopup(`<div>Cell <strong>${i},${j}</strong><br/>Picked up token: <strong>${tokenValue}</strong></div>`);
          rect.openPopup();
          return;
        }

        // If player is holding a token, show message (can't pick up more)
        if (heldToken) {
          rect.bindPopup(`<div>Cell <strong>${i},${j}</strong><br/>${currentlyHasToken ? `Token: <strong>${tokenValue}</strong><br/>` : `Empty<br/>`}<em>You are already holding a token (${heldToken.value}).</em></div>`);
          rect.openPopup();
          return;
        }

        // Otherwise, just open the cell popup
        rect.openPopup();
      });
    }
  }
}

// Draw cells initially and when the map is moved
drawCellsInView();
map.on("moveend", () => drawCellsInView());

// Also redraw if player marker is moved (future step)

// Expose a simple API for future steps
export { drawCellsInView, map, playerMarker };
